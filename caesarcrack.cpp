/*
 * Author: Sean Nicholls
 * Date: Wednesday 30th September 2009
 * Comments: Caesar cipher cracker
 *
 */

#include "caesarcrack.h"

// ciphertext
char* ciphertext = "BMFY BJ BNXM, BJ WJFINQD GJQNJAJ, FSI BMFY BJ TZWXJQAJX YMNSP, BJ NRFLNSJ TYMJWX YMNSP FQXT. ";

// english alphabet
char* eng_alphabet = "abcdefghijklmnopqrstuvwxyz";

// character frequency table
// expressed as percentages
float eng_freq[] = {	0.8167,		// A
						0.1492,		// B
						0.2782,		// C
						0.4253,		// D
						0.12702,	// E
						0.2228,		// F
						0.2015,		// G
						0.6094,		// H
						0.6966,		// I
						0.0153,		// J
						0.0772,		// K
						0.4025,		// L
						0.2406,		// M
						0.6749,		// N
						0.7507,		// O
						0.1929,		// P
						0.0095,		// Q
						0.5987,		// R
						0.6327,		// S
						0.9056,		// T
						0.2758,		// U
						0.0978,		// V
						0.2360,		// W
						0.0150,		// X
						0.1974,		// Y
						0.0074	};	// Z

// program entry
int main (int argc, char * const argv[]) {
	
	// load from file
	if(argc == 3) {
		if( ae_load_file_to_memory(argv[1], &ciphertext) < 0) {
			std::cout << "Could not load file: " << argv[1];
			exit(1);
		} else if( ae_load_file_to_memory(argv[2], &eng_alphabet) < 0 ) {
			std::cout << "Could not load file: " << argv[2];
			exit(1);
		}
	}
	
	// compute the shift register
	int shift = computeShiftRegister( ciphertext, eng_alphabet, eng_freq );
	
	// printout
	std::cout << "Caesar shift register computed to be: " << shift << "\n";
	std::cout << decodeCipher( ciphertext, eng_alphabet, shift ) << "\n";
	
    return 0;
}

// decode a ciphertext using the given alphabet & shift register
char* decodeCipher( char* cipher, char* alpha, int offset ) {
	
	// sanitize input
	cipher = toupperCharArray(ciphertext);
	alpha = tolowerCharArray(alpha);
	
	// get the conversion-alphabet
	char* shiftalpha = toupperCharArray(shiftAlphabet(alpha, offset));
	
	// replace all encoded characters
	// with those of the known alphabet
	for(int i=0; i<strlen(alpha); i++) {				
		for(int j=0; j<strlen(cipher); j++) {			
			if(cipher[j] == shiftalpha[i]) {				
				cipher[j] = tolower(alpha[i]);
			}			
		}
	}
	
	return cipher;
	
}

// computer the offset, or 'shift register' for the caesian shift cipher
int computeShiftRegister( char* cipher, char* alpha, float* langfreq ) {
		
	// speed up computation by using a sample of the cipher
	// this is completely optional, but due to the calculations
	// required, if the text input is large, computation could
	// be slowed significantly with little to no benefit.
	if(strlen(cipher) > 100) {
		cipher = substr( cipher, 0, 100 );
	}
	
	// convert all characters to uppercase
	// this helps conversion, without this
	// the same letter can be replaced more
	// than once.
	cipher = toupperCharArray(cipher);
	alpha = toupperCharArray(alpha);
	
	int shift = 0;					// shift register
	float chival = 101.0f;			// begin with a value larger than expected
	float shiftchi = 101.0f;		// values are percentages, so > 100 is perfect
	char* shiftedAlphabet = "";
	for(int i=0; i<strlen(alpha); i++) {		
		
		// shift the alphabet
		shiftedAlphabet = shiftAlphabet(alpha, i);	
		
		// get the chi value for the shifted alphabet
		chival = getCharFrequencyChiSum( shiftedAlphabet, cipher, langfreq );
		
		// in Chi Square Distribution, we are interested in
		// the value of LEAST deviation. hense we save the
		// shift register with the least 'chi summed value'.
		
		if(chival < shiftchi) {
			shiftchi = chival;
			shift = i;
		}
	}
	return shift;
	
}

// shift an alphabet by a given offset
char* shiftAlphabet( char* str, int offset ) {
	
	char* strout = new char[strlen(str)];
	for(int i=0; i<strlen(str); i++) {
		strout[i] = str[ (i + offset) % strlen(str) ];
	}
	return strout;
	
}

// c++ method to convert char* to uppercase
char* toupperCharArray( char* str ) {
	
	char* strout = new char[strlen(str)];
	for(int i=0; i<strlen(str); i++) {
		strout[i] = toupper(str[i]);
	}
	return strout;
	
}

// c++ method to convert char* to lowercase
char* tolowerCharArray( char* str ) {
	
	char* strout = new char[strlen(str)];
	for(int i=0; i<strlen(str); i++) {
		strout[i] = tolower(str[i]);
	}
	return strout;
	
}

// to speed up analysis, sample a portion of text
char* substr( char* str, int start, int end ) {
	
	char* out = new char[ (end - start) ];
	int j = 0;
	for(int i=start; i<end; i++) {
		out[ j++ ] = str[i];
	}
	return out;
	
}

// calculate the character frequency, from a given text
float countCharFrequency( char c, char* str ) {

	float count = 0;
	float freq = 0.0f;
	
	for(int i=0; i<strlen(str); i++) {
		if(str[i] == c) {
			count++;
		}
	}
	
	freq = (count / strlen(str));
	return freq;
}

// calculate the 'Chi Square Distribution Sum' of a given ciphertext, using a specified alphabet
// and language frequency table
float getCharFrequencyChiSum( char* alpha, char* cipher, float* langfreq ) {
	
	float freq = 0.0f;
	for(int i=0; i<strlen(alpha); i++) {
		freq += countCharFrequency(alpha[i], cipher) / langfreq[i];
	}	
	
	return freq;
}
